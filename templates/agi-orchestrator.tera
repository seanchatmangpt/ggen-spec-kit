{# AGI Orchestrator Template - Generates Python multi-agent orchestrator from RDF #}
{# Constitutional equation: agi/orchestrator.py = μ(agi-agents.ttl) #}
{# This template implements μ₃ EMIT stage of the constitutional equation #}

{%- set orch = sparql_results | first -%}

"""
agi.orchestrator - AGI Multi-Agent Orchestrator
{{ "=" | repeat(count=50) }}

Autonomous orchestration system for coordinating multiple AGI agents.

This module provides orchestration capabilities for AGI systems, enabling:
- Agent lifecycle management
- Task distribution and load balancing
- Inter-agent communication
- Coordination protocols

Auto-generated from: ontology/agi-agents.ttl
Constitutional equation: orchestrator.py = μ(agi-agents.ttl)
DO NOT EDIT MANUALLY - Edit the RDF source instead.

Examples
--------
    >>> orch = Orchestrator()
    >>> orch.register_agent(planner_agent)
    >>> orch.register_agent(implementer_agent)
    >>> result = orch.execute(goal="Build web scraper")

See Also
--------
- :mod:`agi.ops.orchestrator` : Business logic
- :mod:`agi.runtime.orchestrator` : Runtime layer
- :mod:`agi.agents` : Agent implementations
"""

from __future__ import annotations

import asyncio
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Optional
from uuid import uuid4

from opentelemetry import trace

from specify_cli.core.telemetry import span, timed

tracer = trace.get_tracer(__name__)


# ============================================================================
# Orchestration Types
# ============================================================================

class AgentStatus(Enum):
    """Current status of an agent."""

    IDLE = "idle"
    BUSY = "busy"
    FAILED = "failed"
    OFFLINE = "offline"


class OrchestrationType(Enum):
    """Orchestration coordination pattern."""

    SEQUENTIAL = "sequential"  # One agent at a time
    PARALLEL = "parallel"  # All agents simultaneously
    PIPELINE = "pipeline"  # Output of one → input of next
    CONSENSUS = "consensus"  # Agents vote on decision


@dataclass
class AgentRegistration:
    """
    Registered agent in orchestration system.

    Attributes
    ----------
    id : str
        Unique agent identifier
    name : str
        Human-readable agent name
    capabilities : list[str]
        Agent capabilities/skills
    status : AgentStatus
        Current agent status
    max_concurrent_tasks : int
        Maximum parallel tasks
    current_tasks : list[str]
        Currently executing task IDs
    metadata : dict[str, Any]
        Additional agent metadata
    registered_at : datetime
        Registration timestamp
    """

    id: str
    name: str
    capabilities: list[str] = field(default_factory=list)
    status: AgentStatus = AgentStatus.IDLE
    max_concurrent_tasks: int = 1
    current_tasks: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)
    registered_at: datetime = field(default_factory=datetime.now)

    @property
    def is_available(self) -> bool:
        """Check if agent can accept new tasks."""
        return (
            self.status == AgentStatus.IDLE
            and len(self.current_tasks) < self.max_concurrent_tasks
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert registration to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "capabilities": self.capabilities,
            "status": self.status.value,
            "max_concurrent_tasks": self.max_concurrent_tasks,
            "current_tasks": self.current_tasks,
            "metadata": self.metadata,
            "registered_at": self.registered_at.isoformat(),
        }


@dataclass
class AgentTask:
    """
    Task assigned to an agent.

    Attributes
    ----------
    id : str
        Unique task identifier
    agent_id : str
        Assigned agent ID
    description : str
        Task description
    goal : str
        Task goal
    input_data : dict[str, Any]
        Task input parameters
    output_data : dict[str, Any]
        Task output results
    started_at : Optional[datetime]
        Task start time
    completed_at : Optional[datetime]
        Task completion time
    status : str
        Task status (pending, running, completed, failed)
    metadata : dict[str, Any]
        Additional task metadata
    """

    id: str
    agent_id: str
    description: str
    goal: str
    input_data: dict[str, Any] = field(default_factory=dict)
    output_data: dict[str, Any] = field(default_factory=dict)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    status: str = "pending"
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert task to dictionary."""
        return {
            "id": self.id,
            "agent_id": self.agent_id,
            "description": self.description,
            "goal": self.goal,
            "input_data": self.input_data,
            "output_data": self.output_data,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "status": self.status,
            "metadata": self.metadata,
        }


@dataclass
class OrchestrationResult:
    """
    Result of orchestrated execution.

    Attributes
    ----------
    goal : str
        Original goal
    success : bool
        Whether execution succeeded
    tasks : list[AgentTask]
        Executed tasks
    total_duration_ms : int
        Total execution time
    agent_stats : dict[str, Any]
        Per-agent statistics
    metadata : dict[str, Any]
        Additional result metadata
    timestamp : datetime
        Completion timestamp
    """

    goal: str
    success: bool
    tasks: list[AgentTask] = field(default_factory=list)
    total_duration_ms: int = 0
    agent_stats: dict[str, Any] = field(default_factory=dict)
    metadata: dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict[str, Any]:
        """Convert result to dictionary."""
        return {
            "goal": self.goal,
            "success": self.success,
            "tasks": [t.to_dict() for t in self.tasks],
            "total_duration_ms": self.total_duration_ms,
            "agent_stats": self.agent_stats,
            "metadata": self.metadata,
            "timestamp": self.timestamp.isoformat(),
        }


# ============================================================================
# Orchestrator
# ============================================================================

class Orchestrator:
    """
    {{ orch.description | default(value="Multi-agent orchestration system") }}.

    Implements {{ orch.orchestrationType | default(value="distributed") }}
    orchestration with {{ orch.coordinationProtocol | default(value="pub-sub") }} coordination.

    Attributes
    ----------
    agents : dict[str, AgentRegistration]
        Registered agents by ID
    tasks : dict[str, AgentTask]
        Active tasks by ID
    default_type : OrchestrationType
        Default orchestration pattern

    Methods
    -------
    register_agent(agent)
        Register new agent
    unregister_agent(agent_id)
        Remove agent
    execute(goal, orchestration_type)
        Execute goal using orchestrated agents
    assign_task(task, agent_id)
        Assign task to specific agent

    Notes
    -----
    Uses OpenTelemetry for observability.
    All orchestration operations are traced.
    """

    def __init__(
        self,
        default_type: OrchestrationType = OrchestrationType.{{ orch.defaultType | default(value="SEQUENTIAL") }},
        max_retries: int = {{ orch.maxRetries | default(value="3") }},
    ) -> None:
        """
        Initialize orchestrator.

        Parameters
        ----------
        default_type : OrchestrationType
            Default orchestration pattern
        max_retries : int
            Maximum task retry attempts
        """
        self.agents: dict[str, AgentRegistration] = {}
        self.tasks: dict[str, AgentTask] = {}
        self.default_type = default_type
        self.max_retries = max_retries
        self._capability_index: dict[str, list[str]] = defaultdict(list)

    @timed
    def register_agent(
        self,
        name: str,
        capabilities: list[str],
        max_concurrent_tasks: int = 1,
        metadata: Optional[dict[str, Any]] = None,
    ) -> str:
        """
        Register new agent with orchestrator.

        Parameters
        ----------
        name : str
            Agent name
        capabilities : list[str]
            Agent capabilities/skills
        max_concurrent_tasks : int
            Maximum parallel tasks
        metadata : dict[str, Any], optional
            Additional agent metadata

        Returns
        -------
        str
            Assigned agent ID

        Examples
        --------
        >>> orch = Orchestrator()
        >>> agent_id = orch.register_agent(
        ...     name="planner",
        ...     capabilities=["planning", "decomposition"]
        ... )
        """
        with span("orchestrator.register_agent", attributes={"name": name}):
            agent_id = str(uuid4())

            registration = AgentRegistration(
                id=agent_id,
                name=name,
                capabilities=capabilities,
                max_concurrent_tasks=max_concurrent_tasks,
                metadata=metadata or {},
            )

            self.agents[agent_id] = registration

            # Index by capability
            for capability in capabilities:
                self._capability_index[capability].append(agent_id)

            return agent_id

    @timed
    def unregister_agent(self, agent_id: str) -> None:
        """
        Unregister agent from orchestrator.

        Parameters
        ----------
        agent_id : str
            Agent ID to remove
        """
        with span("orchestrator.unregister_agent", attributes={"agent_id": agent_id}):
            if agent_id not in self.agents:
                raise ValueError(f"Agent not found: {agent_id}")

            agent = self.agents[agent_id]

            # Remove from capability index
            for capability in agent.capabilities:
                if agent_id in self._capability_index[capability]:
                    self._capability_index[capability].remove(agent_id)

            # Remove registration
            del self.agents[agent_id]

    @timed
    def execute(
        self,
        goal: str,
        orchestration_type: Optional[OrchestrationType] = None,
        context: Optional[dict[str, Any]] = None,
    ) -> OrchestrationResult:
        """
        Execute goal using orchestrated agents.

        This method coordinates multiple agents to achieve the specified goal
        using {{ orch.coordinationProtocol | default(value="distributed consensus") }}.

        Parameters
        ----------
        goal : str
            High-level goal to achieve
        orchestration_type : OrchestrationType, optional
            Orchestration pattern to use
        context : dict[str, Any], optional
            Execution context

        Returns
        -------
        OrchestrationResult
            Execution result with agent statistics

        Raises
        ------
        OrchestrationError
            If execution fails

        Examples
        --------
        >>> orch = Orchestrator()
        >>> result = orch.execute(
        ...     goal="Build REST API",
        ...     orchestration_type=OrchestrationType.PIPELINE
        ... )
        >>> print(result.success)
        """
        orch_type = orchestration_type or self.default_type

        with span(
            "orchestrator.execute",
            attributes={"goal": goal, "type": orch_type.value},
        ):
            start_time = datetime.now()

            # TODO: Implement actual orchestration logic
            # This is a placeholder

            tasks: list[AgentTask] = []
            success = True

            # Calculate statistics
            duration_ms = int((datetime.now() - start_time).total_seconds() * 1000)

            agent_stats = {
                agent_id: {
                    "tasks_executed": len([t for t in tasks if t.agent_id == agent_id]),
                    "status": agent.status.value,
                }
                for agent_id, agent in self.agents.items()
            }

            return OrchestrationResult(
                goal=goal,
                success=success,
                tasks=tasks,
                total_duration_ms=duration_ms,
                agent_stats=agent_stats,
            )

    @timed
    def assign_task(
        self,
        description: str,
        goal: str,
        agent_id: Optional[str] = None,
        required_capability: Optional[str] = None,
    ) -> AgentTask:
        """
        Assign task to agent.

        Parameters
        ----------
        description : str
            Task description
        goal : str
            Task goal
        agent_id : str, optional
            Specific agent to assign (if None, auto-select)
        required_capability : str, optional
            Required agent capability

        Returns
        -------
        AgentTask
            Created and assigned task

        Raises
        ------
        ValueError
            If no suitable agent available
        """
        with span("orchestrator.assign_task"):
            # Select agent
            if agent_id:
                if agent_id not in self.agents:
                    raise ValueError(f"Agent not found: {agent_id}")
                selected_agent_id = agent_id
            elif required_capability:
                selected_agent_id = self._find_agent_by_capability(required_capability)
            else:
                selected_agent_id = self._find_available_agent()

            # Create task
            task = AgentTask(
                id=str(uuid4()),
                agent_id=selected_agent_id,
                description=description,
                goal=goal,
            )

            self.tasks[task.id] = task

            # Update agent status
            agent = self.agents[selected_agent_id]
            agent.current_tasks.append(task.id)
            if len(agent.current_tasks) >= agent.max_concurrent_tasks:
                agent.status = AgentStatus.BUSY

            return task

    def _find_agent_by_capability(self, capability: str) -> str:
        """Find available agent with specified capability."""
        candidates = self._capability_index.get(capability, [])

        for agent_id in candidates:
            agent = self.agents[agent_id]
            if agent.is_available:
                return agent_id

        raise ValueError(f"No available agent with capability: {capability}")

    def _find_available_agent(self) -> str:
        """Find any available agent."""
        for agent_id, agent in self.agents.items():
            if agent.is_available:
                return agent_id

        raise ValueError("No available agents")

    def get_agent_stats(self) -> dict[str, Any]:
        """
        Get orchestrator statistics.

        Returns
        -------
        dict[str, Any]
            Statistics including agent counts, task counts, etc.
        """
        return {
            "total_agents": len(self.agents),
            "idle_agents": sum(1 for a in self.agents.values() if a.status == AgentStatus.IDLE),
            "busy_agents": sum(1 for a in self.agents.values() if a.status == AgentStatus.BUSY),
            "total_tasks": len(self.tasks),
            "capabilities": list(self._capability_index.keys()),
        }


# ============================================================================
# Exceptions
# ============================================================================

class OrchestrationError(Exception):
    """Raised when orchestration fails."""
    pass
