{# ============================================================================
   Typer Command Generator Template
   ============================================================================
   Constitutional equation: commands/*.py = μ(cli-commands.ttl)

   This template generates Python Typer CLI commands from RDF class definitions.
   Property comments use structured format:
   [type:argument|option] [flag:--name] [short:-x] [default:value] [required:true|false] [env:VAR] [pytype:Type] Description
   ============================================================================ #}
"""
Generated by ggen from cli-commands.ttl
Constitutional equation: commands/*.py = μ(cli-commands.ttl)
DO NOT EDIT THIS FILE MANUALLY - regenerate with: ggen sync
"""

from __future__ import annotations

from pathlib import Path
from typing import Optional

import typer
from rich.console import Console

console = Console()

{# Helper: Extract value from structured comment like [key:value] #}
{# Note: Tera doesn't support regex capture groups easily, so we parse manually #}

{% for class in classes %}
{% if class.name is ending_with("Command") and class.name != "Command" %}
# ============================================================================
# {{ class.name }}
# ============================================================================

{{ class.name | lower | replace(from="command", to="") }}_app = typer.Typer(
    name="{{ class.name | lower | replace(from='command', to='') }}",
    help="""{{ class.comment | replace(from='"@en', to='') | replace(from="@en", to="") }}""",
)


@{{ class.name | lower | replace(from="command", to="") }}_app.callback(invoke_without_command=True)
def {{ class.name | lower | replace(from="command", to="") }}_cmd(
{% for prop in class.properties %}
{% if prop.comment is containing("[type:argument]") %}
    {{ prop.name }}: {% if prop.comment is containing("[pytype:Path]") %}Path{% else %}{{ prop.python_type }}{% endif %}{% if prop.comment is containing("[required:false]") %} | None{% endif %} = typer.Argument(
        {% if prop.comment is containing("[required:false]") %}None{% else %}...{% endif %},
        help="""{{ prop.comment | split(pat="]") | last | replace(from='"@en', to='') | replace(from="@en", to="") | trim }}""",
    ),
{% endif %}
{% endfor %}
{% for prop in class.properties %}
{% if prop.comment is containing("[type:option]") %}
    {{ prop.name }}: {% if prop.comment is containing("[pytype:Path]") %}Path | None{% elif prop.python_type == "int" %}int{% elif prop.python_type == "float" %}float{% elif prop.python_type == "bool" %}bool{% else %}{{ prop.python_type }} | None{% endif %} = typer.Option(
        {% if prop.comment is containing("[default:false]") %}False{% elif prop.comment is containing("[default:true]") %}True{% elif prop.comment is containing("[default:") %}None{% elif prop.comment is containing("[required:false]") %}None{% else %}...{% endif %},
        {% if prop.comment is containing("[flag:") %}"{{ prop.comment | split(pat="[flag:") | last | split(pat="]") | first }}"{% else %}"--{{ prop.name | replace(from='_', to='-') }}"{% endif %}{% if prop.comment is containing("[short:") %},
        "{{ prop.comment | split(pat="[short:") | last | split(pat="]") | first }}"{% endif %},
        help="""{{ prop.comment | split(pat="]") | last | replace(from='"@en', to='') | replace(from="@en", to="") | trim }}""",
    ),
{% endif %}
{% endfor %}
) -> None:
    """{{ class.comment | replace(from='"@en', to='') | replace(from="@en", to="") }}"""
    # Delegate to ops layer (three-tier architecture)
    console.print(f"[dim]{{ class.name }} executed[/dim]")


{% endif %}
{% endfor %}

# ============================================================================
# Main Application Assembly
# ============================================================================

app = typer.Typer(
    name="specify",
    help="Specify CLI - RDF-first spec-driven development toolkit",
)

# Register command groups
{% for class in classes %}
{% if class.name == "GgenCommand" %}
app.add_typer(ggen_app, name="ggen")
{% elif class.name == "PmCommand" %}
app.add_typer(pm_app, name="pm")
{% elif class.name == "SpiffCommand" %}
app.add_typer(spiff_app, name="wf")
{% endif %}
{% endfor %}

# Register root commands
{% for class in classes %}
{% if class.name == "InitCommand" %}
app.add_typer(init_app, name="init")
{% elif class.name == "CheckCommand" %}
app.add_typer(check_app, name="check")
{% elif class.name == "VersionCommand" %}
app.add_typer(version_app, name="version")
{% endif %}
{% endfor %}


def main() -> None:
    """Entry point."""
    app()


if __name__ == "__main__":
    main()
