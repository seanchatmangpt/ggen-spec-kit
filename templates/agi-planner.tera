{# AGI Planner Template - Generates Python task planning class from RDF specifications #}
{# Constitutional equation: agi/planner.py = μ(agi-agents.ttl) #}
{# This template implements μ₃ EMIT stage of the constitutional equation #}

{%- set planner = sparql_results | first -%}

"""
agi.planner - AGI Task Planning Engine
{{ "=" | repeat(count=50) }}

Autonomous task planning system that decomposes complex goals into executable plans.

This module provides the core planning engine for AGI agents, enabling:
- Goal decomposition into sub-tasks
- Dependency resolution and task ordering
- Resource estimation and allocation
- Plan validation and optimization

Auto-generated from: ontology/agi-agents.ttl
Constitutional equation: planner.py = μ(agi-agents.ttl)
DO NOT EDIT MANUALLY - Edit the RDF source instead.

Examples
--------
    >>> planner = TaskPlanner()
    >>> plan = planner.create_plan(goal="Build web scraper", context={})
    >>> for task in plan.tasks:
    ...     print(f"{task.id}: {task.description}")

See Also
--------
- :mod:`agi.ops.planner` : Business logic for planning
- :mod:`agi.runtime.planner` : Runtime execution layer
- :mod:`agi.types` : Data types and structures
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Optional

from opentelemetry import trace

from specify_cli.core.telemetry import span, timed

tracer = trace.get_tracer(__name__)


# ============================================================================
# Planning Types
# ============================================================================

class TaskPriority(Enum):
    """Task priority levels for plan execution ordering."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class TaskStatus(Enum):
    """Current execution status of a planned task."""

    PENDING = "pending"
    READY = "ready"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    BLOCKED = "blocked"


@dataclass
class Task:
    """
    Individual task within an execution plan.

    Attributes
    ----------
    id : str
        Unique task identifier ({{ planner.taskIdFormat | default(value="UUID") }})
    description : str
        Human-readable task description
    goal : str
        Specific goal this task achieves
    dependencies : list[str]
        IDs of tasks that must complete before this one
    estimated_duration : int
        Estimated completion time in seconds
    priority : TaskPriority
        Execution priority level
    status : TaskStatus
        Current execution status
    assigned_agent : Optional[str]
        Agent assigned to execute this task
    metadata : dict[str, Any]
        Additional task-specific metadata
    created_at : datetime
        Task creation timestamp
    """

    id: str
    description: str
    goal: str
    dependencies: list[str] = field(default_factory=list)
    estimated_duration: int = 300  # 5 minutes default
    priority: TaskPriority = TaskPriority.MEDIUM
    status: TaskStatus = TaskStatus.PENDING
    assigned_agent: Optional[str] = None
    metadata: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)

    def is_ready(self, completed_tasks: set[str]) -> bool:
        """
        Check if task is ready for execution based on dependencies.

        Parameters
        ----------
        completed_tasks : set[str]
            Set of task IDs that have completed

        Returns
        -------
        bool
            True if all dependencies are satisfied
        """
        return all(dep_id in completed_tasks for dep_id in self.dependencies)

    def to_dict(self) -> dict[str, Any]:
        """Convert task to dictionary representation."""
        return {
            "id": self.id,
            "description": self.description,
            "goal": self.goal,
            "dependencies": self.dependencies,
            "estimated_duration": self.estimated_duration,
            "priority": self.priority.value,
            "status": self.status.value,
            "assigned_agent": self.assigned_agent,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
        }


@dataclass
class ExecutionPlan:
    """
    Complete execution plan for achieving a goal.

    Attributes
    ----------
    goal : str
        High-level goal to achieve
    tasks : list[Task]
        Ordered list of tasks in execution plan
    context : dict[str, Any]
        Planning context and constraints
    estimated_total_duration : int
        Total estimated completion time in seconds
    created_at : datetime
        Plan creation timestamp
    metadata : dict[str, Any]
        Additional plan-level metadata
    """

    goal: str
    tasks: list[Task] = field(default_factory=list)
    context: dict[str, Any] = field(default_factory=dict)
    estimated_total_duration: int = 0
    created_at: datetime = field(default_factory=datetime.now)
    metadata: dict[str, Any] = field(default_factory=dict)

    def get_ready_tasks(self, completed_tasks: set[str]) -> list[Task]:
        """
        Get all tasks ready for execution.

        Parameters
        ----------
        completed_tasks : set[str]
            Set of completed task IDs

        Returns
        -------
        list[Task]
            Tasks with satisfied dependencies, ordered by priority
        """
        ready = [
            task for task in self.tasks
            if task.status == TaskStatus.PENDING and task.is_ready(completed_tasks)
        ]
        # Sort by priority (CRITICAL first)
        priority_order = {
            TaskPriority.CRITICAL: 0,
            TaskPriority.HIGH: 1,
            TaskPriority.MEDIUM: 2,
            TaskPriority.LOW: 3,
        }
        return sorted(ready, key=lambda t: priority_order[t.priority])

    def to_dict(self) -> dict[str, Any]:
        """Convert plan to dictionary representation."""
        return {
            "goal": self.goal,
            "tasks": [task.to_dict() for task in self.tasks],
            "context": self.context,
            "estimated_total_duration": self.estimated_total_duration,
            "created_at": self.created_at.isoformat(),
            "metadata": self.metadata,
        }


# ============================================================================
# Task Planner
# ============================================================================

class TaskPlanner:
    """
    {{ planner.description | default(value="Autonomous task planning engine for goal decomposition") }}.

    This planner implements {{ planner.planningAlgorithm | default(value="hierarchical task network") }}
    decomposition to break complex goals into executable task sequences.

    Attributes
    ----------
    max_depth : int
        Maximum decomposition depth ({{ planner.maxDepth | default(value="5") }})
    max_tasks : int
        Maximum tasks per plan ({{ planner.maxTasks | default(value="50") }})

    Methods
    -------
    create_plan(goal, context)
        Decompose goal into execution plan
    validate_plan(plan)
        Validate plan structure and dependencies
    optimize_plan(plan)
        Optimize task ordering and resource allocation

    Notes
    -----
    Uses OpenTelemetry for observability.
    All operations are instrumented with spans and timing.
    """

    def __init__(
        self,
        max_depth: int = {{ planner.maxDepth | default(value="5") }},
        max_tasks: int = {{ planner.maxTasks | default(value="50") }},
    ) -> None:
        """
        Initialize task planner.

        Parameters
        ----------
        max_depth : int
            Maximum decomposition depth
        max_tasks : int
            Maximum tasks allowed in a plan
        """
        self.max_depth = max_depth
        self.max_tasks = max_tasks
        self._task_counter = 0

    @timed
    def create_plan(
        self,
        goal: str,
        context: dict[str, Any] | None = None,
    ) -> ExecutionPlan:
        """
        Create execution plan for achieving goal.

        This method decomposes the high-level goal into concrete tasks using
        {{ planner.planningAlgorithm | default(value="hierarchical decomposition") }}.

        Parameters
        ----------
        goal : str
            High-level goal to achieve
        context : dict[str, Any], optional
            Planning context (constraints, resources, etc.)

        Returns
        -------
        ExecutionPlan
            Complete execution plan with ordered tasks

        Raises
        ------
        ValueError
            If goal is invalid or cannot be decomposed
        PlanningError
            If planning fails or violates constraints

        Examples
        --------
        >>> planner = TaskPlanner()
        >>> plan = planner.create_plan(
        ...     goal="Build REST API",
        ...     context={"language": "Python", "framework": "FastAPI"}
        ... )
        >>> print(f"Plan has {len(plan.tasks)} tasks")
        """
        with span("planner.create_plan", attributes={"goal": goal}):
            ctx = context or {}

            # Initialize plan
            plan = ExecutionPlan(goal=goal, context=ctx)

            # Decompose goal into tasks
            tasks = self._decompose_goal(goal, ctx, depth=0)

            # Validate task count
            if len(tasks) > self.max_tasks:
                raise ValueError(
                    f"Plan exceeds maximum tasks: {len(tasks)} > {self.max_tasks}"
                )

            # Assign tasks to plan
            plan.tasks = tasks
            plan.estimated_total_duration = sum(t.estimated_duration for t in tasks)

            # Validate plan structure
            self.validate_plan(plan)

            return plan

    def _decompose_goal(
        self,
        goal: str,
        context: dict[str, Any],
        depth: int,
    ) -> list[Task]:
        """
        Recursively decompose goal into tasks.

        Parameters
        ----------
        goal : str
            Goal to decompose
        context : dict[str, Any]
            Decomposition context
        depth : int
            Current decomposition depth

        Returns
        -------
        list[Task]
            Decomposed tasks
        """
        with span("planner.decompose", attributes={"depth": depth, "goal": goal}):
            if depth >= self.max_depth:
                # Base case: create atomic task
                return [self._create_task(goal, context)]

            # TODO: Implement actual decomposition logic
            # This is a placeholder - real implementation would use LLM or rules

            # For now, create placeholder task
            return [self._create_task(goal, context)]

    def _create_task(
        self,
        description: str,
        context: dict[str, Any],
    ) -> Task:
        """
        Create new task with unique ID.

        Parameters
        ----------
        description : str
            Task description
        context : dict[str, Any]
            Task context

        Returns
        -------
        Task
            Newly created task
        """
        self._task_counter += 1
        return Task(
            id=f"task_{self._task_counter:04d}",
            description=description,
            goal=description,
            metadata={"context": context},
        )

    @timed
    def validate_plan(self, plan: ExecutionPlan) -> bool:
        """
        Validate plan structure and dependencies.

        Parameters
        ----------
        plan : ExecutionPlan
            Plan to validate

        Returns
        -------
        bool
            True if plan is valid

        Raises
        ------
        ValueError
            If plan structure is invalid
        """
        with span("planner.validate", attributes={"goal": plan.goal}):
            # Check for circular dependencies
            visited: set[str] = set()

            def has_cycle(task_id: str, path: set[str]) -> bool:
                if task_id in path:
                    return True
                if task_id in visited:
                    return False

                visited.add(task_id)
                path.add(task_id)

                task = next((t for t in plan.tasks if t.id == task_id), None)
                if task:
                    for dep in task.dependencies:
                        if has_cycle(dep, path):
                            return True

                path.remove(task_id)
                return False

            for task in plan.tasks:
                if has_cycle(task.id, set()):
                    raise ValueError(f"Circular dependency detected involving {task.id}")

            return True

    @timed
    def optimize_plan(self, plan: ExecutionPlan) -> ExecutionPlan:
        """
        Optimize task ordering and resource allocation.

        Parameters
        ----------
        plan : ExecutionPlan
            Plan to optimize

        Returns
        -------
        ExecutionPlan
            Optimized execution plan

        Notes
        -----
        Optimization strategies:
        - Critical path analysis
        - Parallel task identification
        - Resource load balancing
        """
        with span("planner.optimize", attributes={"goal": plan.goal}):
            # TODO: Implement optimization algorithms
            # - Topological sort for optimal ordering
            # - Critical path method (CPM)
            # - Resource leveling

            return plan


# ============================================================================
# Exceptions
# ============================================================================

class PlanningError(Exception):
    """Raised when planning operation fails."""
    pass
