# 27. Idempotent Transform

★★★

*Run it once. Run it twice. Run it a hundred times. The result is always the same. Idempotent transformation is the mathematical foundation of reliable artifact generation—the property that makes "just regenerate" always safe.*

---

## The Safety of Repetition

The most powerful debugging strategy in specification-driven development is simple: "Just regenerate." Uncertain if the artifact is correct? Regenerate. Suspect drift? Regenerate. Merging changes? Regenerate.

This strategy works only because transformation is idempotent:

```
μ(μ(s)) = μ(s)

Running the transformation twice on the same source
produces the same result as running it once.
```

Idempotence means regeneration is always safe. You can never make things worse by running the transformation again. You can never introduce divergence by regenerating. The system converges to correctness through repetition.

---

## The Stability Problem

**The fundamental challenge: Non-idempotent transformations create instability. Each run produces different output, even with unchanged input. This makes verification impossible, diffing meaningless, and trust unattainable.**

Let us examine what breaks idempotence:

### The Timestamp Trap

Embedding generation timestamp in output:

```python
# Generated at: 2025-01-15T10:30:00Z  # <-- Changes every run!
def validate():
    ...
```

Every regeneration changes this comment, even with no source changes. Git shows diffs. CI flags changes. The noise obscures real modifications.

### The Random ID Problem

Generating identifiers randomly:

```yaml
# config.yaml
instance_id: f47ac10b-58cc-4372-a567-0e02b2c3d479  # Random UUID!
```

Each regeneration creates a new ID. Configuration drift occurs even with identical specifications.

### The Order Instability

Non-deterministic iteration order:

```python
# Sets have undefined iteration order
for key in some_set:  # Undefined order!
    generate(key)
```

Output order varies between runs. Same specification, different artifact.

### The Environmental Dependency

Output depending on runtime environment:

```python
# Generated on: {os.name}  # Different per platform!
import socket
hostname = socket.gethostname()  # Different per machine!
```

The artifact varies based on where transformation runs.

---

## The Forces

Several tensions challenge idempotence:

### Force: Freshness vs. Stability

*Timestamps show when artifacts were generated. But timestamps break idempotence.*

Users want to know "when was this generated?" But including that information creates instability.

**Resolution:** Record freshness in receipts, not in artifacts. The artifact is timeless; the receipt records provenance.

### Force: Uniqueness vs. Reproducibility

*Some systems need unique identifiers. But random generation breaks idempotence.*

If you need a UUID, where does it come from?

**Resolution:** Derive identifiers deterministically from content. Hash-based IDs are unique AND reproducible.

### Force: Rich Output vs. Minimal Diff

*Rich output provides context. But more output means more potential for variation.*

Including helpful metadata makes artifacts self-documenting but increases surface area for idempotence violations.

**Resolution:** Include only deterministic metadata. Everything else goes in receipts.

### Force: Performance vs. Purity

*Caching improves performance. But caches can cause inconsistency.*

A cached query result from yesterday doesn't match today's regeneration if the source changed.

**Resolution:** Cache carefully. Invalidate on source hash change. Or regenerate everything for guaranteed consistency.

---

## Therefore

**Design transformations to be mathematically idempotent: given unchanged inputs, the output is byte-for-byte identical across any number of runs, on any platform, at any time.**

The idempotence guarantee:

```
∀ source s, ∀ n ≥ 1: μⁿ(s) = μ(s)

For any source s and any number of applications n,
the result is identical to a single application.
```

This is equivalent to:

```
μ ∘ μ = μ

The composition of μ with itself equals μ.
```

---

## Achieving Idempotence

### Rule 1: No Timestamps in Output

```python
# WRONG: Timestamp in output
"""Generated: {{ now() }}"""  # Breaks idempotence!

# RIGHT: Static provenance, dynamic timestamp in receipt
"""Generated by ggen. See accompanying receipt for details."""
```

If you need timestamps, use the source file's modification time:

```python
# Acceptable: Source-derived timestamp
source_mtime = os.path.getmtime(source_file)
generated_at = datetime.fromtimestamp(source_mtime).isoformat()
```

But better: put timestamps only in receipts.

### Rule 2: Deterministic Identifiers

```python
# WRONG: Random UUID
instance_id = uuid.uuid4()

# RIGHT: Content-derived ID
instance_id = hashlib.sha256(content.encode()).hexdigest()[:16]
```

Content-derived IDs are:
- Unique (collision-resistant hash)
- Reproducible (same content → same ID)
- Verifiable (re-compute to check)

### Rule 3: Sorted Iteration

```python
# WRONG: Unordered iteration
for command in commands:  # Order undefined!
    generate(command)

# RIGHT: Explicit ordering
for command in sorted(commands, key=lambda c: c.name):
    generate(command)
```

SPARQL queries must include ORDER BY:

```sparql
# WRONG
SELECT ?name WHERE { ?cmd a cli:Command ; rdfs:label ?name }

# RIGHT
SELECT ?name WHERE { ?cmd a cli:Command ; rdfs:label ?name }
ORDER BY ?name
```

### Rule 4: Canonical Formatting

```python
# WRONG: Platform-dependent line endings
content = template.render()  # Uses platform default

# RIGHT: Explicit line ending
content = template.render()
content = content.replace('\r\n', '\n')  # Always LF
```

See **[25. Canonicalization](./canonicalization.md)** for comprehensive formatting normalization.

### Rule 5: Environment Independence

```python
# WRONG: Environment in output
author = os.environ.get('USER', 'unknown')
hostname = socket.gethostname()

# RIGHT: Fixed values in output, environment in receipt
author = "ggen"  # In artifact
# Store actual user/host in receipt only
```

### Rule 6: Deterministic Templates

Template engines must be configured for determinism:

```python
# Tera: Ensure consistent behavior
env = Environment()
env.undefined = StrictUndefined  # Fail on undefined, don't substitute

# Jinja2: Same
env = jinja2.Environment(undefined=jinja2.StrictUndefined)
```

### Rule 7: Deterministic JSON

```python
# WRONG: Order not guaranteed
json.dumps(data)  # {"b": 1, "a": 2} or {"a": 2, "b": 1}?

# RIGHT: Sort keys
json.dumps(data, sort_keys=True)  # Always {"a": 2, "b": 1}
```

### Rule 8: Sort File Lists

```python
# WRONG: Filesystem order varies
for file in Path(".").glob("*.ttl"):
    process(file)  # Order varies by filesystem!

# RIGHT: Sort results
for file in sorted(Path(".").glob("*.ttl")):
    process(file)  # Consistent order
```

---

## Verification Strategies

### Strategy 1: Double-Run Test

The simplest idempotence test:

```bash
#!/bin/bash
# Test idempotence

# First run
ggen sync

# Capture state
sha256sum output/* > first_run.txt

# Second run
ggen sync

# Capture state again
sha256sum output/* > second_run.txt

# Compare
diff first_run.txt second_run.txt
if [ $? -ne 0 ]; then
    echo "IDEMPOTENCE VIOLATION: Output differs between runs!"
    exit 1
fi

echo "Idempotent ✓"
```

### Strategy 2: Cross-Platform Test

Test that output is identical across platforms:

```yaml
# .github/workflows/idempotence.yml
jobs:
  generate:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate artifacts
        run: ggen sync
      - name: Compute hashes
        run: |
          find output -type f -exec sha256sum {} \; | sort > hashes.txt
      - uses: actions/upload-artifact@v4
        with:
          name: hashes-${{ matrix.os }}
          path: hashes.txt

  compare:
    needs: generate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
      - name: Compare hashes
        run: |
          diff hashes-ubuntu-latest/hashes.txt hashes-macos-latest/hashes.txt || exit 1
          diff hashes-ubuntu-latest/hashes.txt hashes-windows-latest/hashes.txt || exit 1
          echo "Cross-platform idempotence verified ✓"
```

### Strategy 3: Time-Lapse Test

Generate, wait, regenerate:

```python
import time

def test_idempotence_over_time():
    """Verify idempotence regardless of time passage."""
    # Generate
    subprocess.run(["ggen", "sync"], check=True)
    first_hashes = compute_hashes("output/")

    # Wait (simulate time passage)
    time.sleep(5)

    # Regenerate
    subprocess.run(["ggen", "sync"], check=True)
    second_hashes = compute_hashes("output/")

    # Compare
    assert first_hashes == second_hashes, "Idempotence violated over time!"
```

### Strategy 4: Clean Room Test

Generate in pristine environment:

```bash
# Test in pristine environment
docker run --rm -v $(pwd):/workspace alpine sh -c "
    cd /workspace
    ggen sync
    find output -type f -exec sha256sum {} \; | sort
" > clean_hashes.txt

# Compare with local
find output -type f -exec sha256sum {} \; | sort > local_hashes.txt
diff clean_hashes.txt local_hashes.txt || {
    echo "Environment dependency detected!"
    exit 1
}
```

---

## Common Violations and Fixes

### Violation: Template with Timestamp

```jinja
{# VIOLATION #}
# Generated: {{ now() | date(format="%Y-%m-%d %H:%M:%S") }}

{# FIX: Remove timestamp from template #}
# Generated by ggen. See .receipt file for generation details.
```

### Violation: Non-Deterministic JSON

```python
# VIOLATION: Python dicts are ordered, but JSON stringify might not be
import json
data = {"b": 1, "a": 2}
json.dumps(data)  # Order might vary

# FIX: Sort keys
json.dumps(data, sort_keys=True)  # Always {"a": 2, "b": 1}
```

### Violation: Floating-Point Formatting

```python
# VIOLATION: Float representation varies
value = 1.0 / 3.0
f"{value}"  # "0.3333333333333333" or "0.33333333333333331"?

# FIX: Explicit formatting
f"{value:.15f}"  # Always "0.333333333333333"
```

### Violation: Hash Set Iteration

```python
# VIOLATION: Set iteration order is undefined
tags = {"alpha", "beta", "gamma"}
for tag in tags:
    generate(tag)  # Order varies!

# FIX: Sort before iterating
for tag in sorted(tags):
    generate(tag)  # Consistent order
```

### Violation: Dictionary Comprehension

```python
# VIOLATION (subtle): Dict comprehension iterates over unordered source
data = {row['name']: row for row in results}  # If results unordered, so is data

# FIX: Sort results first
data = {row['name']: row for row in sorted(results, key=lambda r: r['name'])}
```

---

## Configuration

```toml
# ggen.toml

[idempotence]
# Enable idempotence checks
verify_on_sync = true

# What to verify
[idempotence.checks]
no_timestamps = true
sorted_output = true
deterministic_ids = true
canonical_format = true

# How to handle violations
on_violation = "error"  # error | warn | ignore

# Excluded files (known non-idempotent by design)
exclude = [
    "*.log",
    "build-info.json"  # Intentionally includes timestamps
]
```

---

## Case Study: The Flaky CI

*A team discovers hidden idempotence violations through CI failures.*

### The Situation

The DataOps team had passing tests locally, but CI failed randomly:

```
CI Run #142: ✓ PASSED
CI Run #143: ✗ FAILED - unexpected diff in validate.py
CI Run #144: ✓ PASSED
CI Run #145: ✗ FAILED - unexpected diff in check.py
```

No code changes between runs. Pure randomness.

### The Investigation

They added diagnostic output:

```yaml
- name: Debug generation
  run: |
    ggen sync
    sha256sum src/commands/*.py > run1.txt
    ggen sync
    sha256sum src/commands/*.py > run2.txt
    diff run1.txt run2.txt || echo "IDEMPOTENCE FAILURE"
```

Result: Hashes differed between runs! The transformation was not idempotent.

### The Root Cause

Three violations were found:

**Violation 1: Random Import Order**

```jinja
{# Template was iterating over an unordered set #}
{% for import in imports %}
import {{ import }}
{% endfor %}
```

The imports appeared in different orders between runs.

**Violation 2: Dict Comprehension Order**

```python
# Query results weren't sorted
data = {row['name']: row['value'] for row in results}  # Undefined order
```

**Violation 3: Timestamp in Error Messages**

```python
# Generated error messages included generation time
raise ValueError(f"Invalid at {datetime.now()}: {msg}")
```

### The Fix

```jinja
{# Fix 1: Sort imports #}
{% for import in imports | sort %}
import {{ import }}
{% endfor %}
```

```python
# Fix 2: Sort query results
data = {row['name']: row['value']
        for row in sorted(results, key=lambda r: r['name'])}

# Fix 3: Static error messages
raise ValueError(f"Invalid: {msg}")  # Time in receipt, not code
```

### The Result

After fixes:

```
CI Runs #146-#200: ✓ ALL PASSED
Zero flaky failures
100% reproducible builds
```

---

## Anti-Patterns

### Anti-Pattern: "Good Enough" Idempotence

*"It's idempotent 99% of the time."*

Partial idempotence is no idempotence. That 1% failure will happen at the worst time—during an audit, a demo, a critical release.

**Resolution:** 100% idempotence or 0%. There's no in-between.

### Anti-Pattern: Idempotence by Caching

*"We cache the output, so regeneration returns the cached version."*

This hides violations rather than fixing them. When the cache is cleared, the violation reappears.

**Resolution:** True idempotence means identical output from fresh computation, not cached retrieval.

### Anti-Pattern: Platform-Specific Expectations

*"It's idempotent on Linux. Windows is different."*

Cross-platform development requires cross-platform idempotence.

**Resolution:** Test on all target platforms. Fix platform-specific variations.

### Anti-Pattern: "We'll Sort Later"

*"The extraction query doesn't sort, but we sort in post-processing."*

Sorting should happen at the earliest opportunity—in the query itself. Relying on later stages to fix earlier violations is fragile.

**Resolution:** Sort at the source. ORDER BY in SPARQL. Sorted iteration in templates.

---

## Implementation Checklist

### Design Phase

- [ ] Identify all sources of non-determinism
- [ ] Design deterministic alternatives
- [ ] Document idempotence requirements
- [ ] Plan verification strategy

### Implementation Phase

- [ ] Remove timestamps from output
- [ ] Use deterministic identifiers
- [ ] Sort all iterations
- [ ] Canonicalize all output
- [ ] Remove environment dependencies
- [ ] Sort JSON keys
- [ ] Sort file system results

### Verification Phase

- [ ] Implement double-run test
- [ ] Implement cross-platform test
- [ ] Add to CI pipeline
- [ ] Monitor for flaky tests

### Maintenance Phase

- [ ] Review new code for violations
- [ ] Test changes for idempotence
- [ ] Document exceptions (if any)
- [ ] Audit periodically

---

## Exercises

### Exercise 1: Find the Violations

Given this template, identify all idempotence violations:

```jinja
# Generated: {{ now() }}
# Instance: {{ uuid() }}
{% for cmd in commands %}
def {{ cmd.name }}():
    """{{ cmd.description }}"""
    tags = {{ cmd.tags }}
    pass
{% endfor %}
```

Fix it to be idempotent.

### Exercise 2: Deterministic IDs

Create a function that generates deterministic IDs:

```python
def deterministic_id(content: str) -> str:
    """Generate a deterministic ID from content."""
    # Your implementation here
```

Requirements:
- Same content → same ID
- Different content → different ID (high probability)
- ID format: 16 hex characters

### Exercise 3: Cross-Platform Test

Write a GitHub Actions workflow that:
1. Generates artifacts on Linux, macOS, and Windows
2. Compares output hashes
3. Fails if any differ

### Exercise 4: Violation Detection

Write a test that detects idempotence violations:

```python
def test_idempotence():
    """Verify transformation is idempotent."""
    # Generate twice, compare results
```

The test should catch:
- Timestamp variations
- Order variations
- Format variations

---

## Resulting Context

After implementing this pattern, you have:

- **Guaranteed stability:** Regeneration produces identical output
- **Safe operations:** "Just regenerate" is always safe
- **Meaningful diffs:** Changes indicate real modifications
- **Reproducible builds:** Any machine, any time, same result
- **Trustworthy CI:** No flaky tests from non-determinism
- **Debuggable transformations:** Problems have consistent reproduction

Idempotence is the mathematical foundation of everything else. Without it, nothing in specification-driven development is reliable. With it, everything becomes predictable.

---

## Related Patterns

- **Enabled by:** **[25. Canonicalization](./canonicalization.md)** — Eliminates format variation
- **Verified by:** **[35. Drift Detection](../verification/drift-detection.md)** — Detects violations
- **Required for:** **[28. Partial Regeneration](./partial-regeneration.md)** — Selective updates
- **Foundation for:** **[26. Receipt Generation](./receipt-generation.md)** — Consistent proofs

---

## Mathematical Note

Idempotence is a fundamental concept in mathematics and computer science:

**In mathematics:** An operation f is idempotent if f(f(x)) = f(x)

Examples:
- Absolute value: ||-5|| = |-5| = 5
- Set intersection: A ∩ A = A
- Maximum: max(max(3,5), max(3,5)) = max(3,5) = 5

**In databases:** An idempotent query returns the same result when run multiple times with unchanged data.

**In HTTP:** PUT and DELETE are idempotent; POST is not.

**In distributed systems:** Idempotent operations can be safely retried on failure.

The μ transformation inherits this powerful property, making it safe in all these contexts.

---

## Philosophical Note

> *"Simplicity is the ultimate sophistication."*
> — Leonardo da Vinci

Idempotence seems like a simple property—do the same thing, get the same result. But achieving it requires sophistication: understanding every source of variation, designing deterministic alternatives, testing across environments and time.

The payoff for this sophistication is profound simplicity in use. "Just regenerate" is the simplest possible instruction. It's safe because idempotence makes it safe. It's reliable because idempotence makes it reliable.

---

**Next:** Learn how **[28. Partial Regeneration](./partial-regeneration.md)** leverages idempotence to update only what's needed.
