# Glossary

★★

*Words matter. In specification-driven development, precision of language enables precision of thought. This glossary defines the key terms used throughout this pattern language, with examples and cross-references to help you internalize the vocabulary.*

---

## How to Use This Glossary

This glossary serves multiple purposes:

1. **Reference**: Look up unfamiliar terms as you read
2. **Learning**: Understand the conceptual framework
3. **Communication**: Use consistent terminology with your team
4. **Precision**: Distinguish similar concepts

### Entry Format

Each entry includes:
- **Term** in bold
- Definition following a colon
- *Example* in italics where helpful
- [See also] cross-references

---

## A

**Acceptance Criterion**
: A specific, testable condition that must be satisfied for a capability to be considered complete. Typically expressed in Given-When-Then format where Given describes preconditions, When describes actions, and Then describes expected outcomes.

*Example:*
```gherkin
Given a user with valid credentials
When they submit the login form
Then they should see the dashboard within 2 seconds
```

[See also: Outcome Desired, Test Before Code]

---

**Anxiety**
: Fear or uncertainty that creates resistance to adopting new solutions. Anxieties operate as counter-forces to the pull of new capabilities. They include fears about the new solution (will it work?), fears about switching (will I lose data?), and fears about commitment (can I go back?).

*Example: A team hesitates to adopt specification-driven development because they worry about learning curve and initial productivity loss.*

[See also: Habit, Forces in Tension, Competing Solutions]

---

**Artifact**
: Any output generated by the transformation pipeline from specifications. Artifacts include source code files, documentation, configuration files, test files, and any other machine-generated content. The constitutional equation guarantees artifacts derive from specifications.

*Types of artifacts:*
- **Code artifacts**: Python modules, TypeScript classes, SQL schemas
- **Documentation artifacts**: Markdown files, HTML pages, man pages
- **Test artifacts**: Test cases, fixtures, mocks
- **Configuration artifacts**: YAML configs, JSON schemas, deployment manifests

[See also: Constitutional Equation, Human-Readable Artifact, Receipt]

---

## B

**Blank Node**
: An anonymous node in an RDF graph, typically used for intermediate structures that don't need global identity. Blank nodes are scoped to their document and should be used sparingly as they complicate graph merging.

*Example:*
```turtle
sk:command sk:hasArgument [
    a sk:Argument ;
    sk:name "file" ;
    sk:type "Path"
] .
```

[See also: URI, Triple, RDF]

---

**Branching Exploration**
: The practice of generating multiple implementation variants from the same specification by creating specification branches. Each branch explores a different approach (algorithm, architecture, trade-off resolution) and can be evaluated against outcome metrics before committing.

*Example: Testing three caching strategies (LRU, LFU, TTL) by creating three specification branches and measuring hit rates in production.*

[See also: Specification Refinement, Gap Analysis, Forces in Tension]

---

**Build-Measure-Learn**
: A cycle from Lean Startup methodology adapted for specification-driven development. Build specifications and generate artifacts, measure outcomes in production, learn from the data, then refine specifications. The cycle accelerates with automated transformation and measurement.

```
        ┌─────────────┐
        │    BUILD    │◄─────────────────────┐
        │ (Specs →    │                      │
        │  Artifacts) │                      │
        └──────┬──────┘                      │
               │                             │
               ▼                             │
        ┌─────────────┐                      │
        │   MEASURE   │               ┌──────┴──────┐
        │ (Outcomes,  │               │    LEARN    │
        │  Telemetry) │               │ (Gap Analysis│
        └──────┬──────┘               │  Refinement)│
               │                      └──────▲──────┘
               └─────────────────────────────┘
```

[See also: Feedback Loop, Outcome Measurement, Specification Refinement]

---

## C

**Canonicalization**
: The fourth stage (μ₄) of the transformation pipeline that normalizes output format. Canonicalization ensures consistent line endings, whitespace, character encoding, and formatting so that semantically identical outputs produce byte-identical artifacts. This is essential for idempotence and drift detection.

*Canonicalization operations:*
- Line endings: Convert to LF (Unix style)
- Trailing whitespace: Remove
- Final newline: Ensure present
- Encoding: UTF-8 without BOM
- Indentation: Consistent (spaces or tabs, configurable)

[See also: Idempotent Transform, Drift Detection, Receipt Generation]

---

**Capability**
: A coherent unit of functionality that helps customers make progress on a job. A capability is more than a feature—it encompasses the full experience from discovery through ongoing use. In this pattern language, capabilities are specified in RDF, transformed into artifacts, and evolved through feedback.

*Example: "User Authentication" is a capability encompassing login, registration, password reset, session management, and security policies.*

[See also: Customer Job, Living System, Progress Maker]

---

**Circumstance**
: The specific situation in which a customer job arises. Circumstances include triggers (what prompts the need), emotional state (stressed, curious, frustrated), time budget (seconds, minutes, hours), and consequences (what happens if the job isn't done). Understanding circumstances reveals design requirements.

*Circumstance components:*
- **Trigger**: What prompts the need?
- **Emotional state**: How does the customer feel?
- **Time budget**: How much time is available?
- **Consequences**: What happens if the job isn't done?

[See also: Customer Job, Outcome Desired, Forces in Tension]

---

**Competing Solution**
: Any alternative way customers might address their job. Competition includes direct competitors, indirect substitutes, manual workarounds, and doing nothing. Understanding competition reveals the true bar for adoption—new solutions must beat all alternatives, not just be "good."

*Categories of competition:*
- **Direct**: Other tools solving the same job
- **Indirect**: Different approaches to the same outcome
- **Manual**: Human effort without tools
- **Non-consumption**: Choosing not to address the job

[See also: Progress Maker, Anxieties and Habits, Forces in Tension]

---

**Constitutional Equation**
: The fundamental principle of specification-driven development: `spec.md = μ(feature.ttl)`. Human-readable artifacts are always generated from formal specifications through a deterministic transformation function μ. The equation is "constitutional" because it governs all artifact creation—violations are unconstitutional.

*The equation components:*
- **spec.md**: Any generated artifact (not just Markdown)
- **=**: Identity through transformation
- **μ**: The five-stage transformation function
- **feature.ttl**: The source specification in RDF

[See also: Transformation Pipeline, Single Source of Truth, Drift Detection]

---

**Contract**
: The promises a capability makes to its consumers. Contracts specify inputs, outputs, preconditions, postconditions, and invariants. In specification-driven development, contracts are derived from specifications and verified through contract tests.

*Contract elements:*
- **Preconditions**: What must be true before invocation
- **Postconditions**: What will be true after successful invocation
- **Invariants**: What remains true throughout
- **Error conditions**: What can go wrong and how it's signaled

[See also: Contract Test, Acceptance Criterion, Shape Constraint]

---

**Contract Test**
: A test that verifies interface promises without testing internal implementation. Contract tests focus on the API surface—inputs, outputs, and observable behavior—not the machinery that produces results. They enable implementation changes while preserving behavior.

*Example:*
```python
def test_search_returns_results():
    """Contract: search returns list of matching items."""
    results = search("query")
    assert isinstance(results, list)
    assert all(hasattr(r, "title") for r in results)
    # Does NOT test how search is implemented
```

[See also: Test Before Code, Acceptance Criterion, Contract]

---

**Customer Job**
: The progress a person is trying to make in a specific circumstance. Jobs include functional dimensions (what they're trying to do), emotional dimensions (how they want to feel), and social dimensions (how they want to be perceived). Jobs are stable even as solutions change.

*Job structure:*
- **Verb**: Action the customer is taking
- **Object**: What they're acting upon
- **Context**: When and where this happens
- **Functional**: Practical progress sought
- **Emotional**: Feelings sought
- **Social**: Perception sought

*Example: "Help me [compile my code] [quickly] [so I can stay in flow] [and look competent to my team]"*

[See also: Circumstance of Struggle, Outcome Desired, Progress Maker]

---

## D

**Deprecation**
: The process of marking a capability as scheduled for retirement. Deprecation signals to users that they should migrate to alternatives. Good deprecation includes clear warnings, documented alternatives, generous timelines, and migration tools.

*Deprecation phases:*
1. **Soft**: Capability works, warnings in documentation only
2. **Hard**: Capability works, runtime warnings emitted
3. **Sunset**: Capability works but blocks new adoption
4. **Removal**: Capability removed entirely

[See also: Deprecation Path, Specification Refinement, Living Documentation]

---

**Domain-Specific Language (DSL)**
: A simplified syntax or pattern that makes common specification tasks easier while remaining valid RDF. DSLs trade expressiveness for ergonomics, providing natural syntax for domain experts without requiring full RDF knowledge.

*Example DSL for commands:*
```
command validate:
  description: "Validate RDF specifications"
  argument file: Path, required
  option --verbose: bool, default false
```

*Expands to full RDF/Turtle specification.*

[See also: Semantic Foundation, Narrative Specification, Layered Ontology]

---

**Drift**
: Divergence between source specification and generated artifact, typically caused by manual editing of generated files. Drift violates the constitutional equation and creates technical debt that compounds over time.

*Drift causes:*
- Manual hotfixes to generated files
- Bypassing the transformation pipeline
- Forgot to regenerate after spec changes
- Merge conflicts resolved incorrectly

[See also: Drift Detection, Constitutional Equation, Single Source of Truth]

---

## E

**Emission**
: See Template Emission.

---

**Executable Specification**
: A specification precise enough to drive validation, extraction, and generation—not just describe intent. Executable specifications include machine-readable constraints, query patterns, and template bindings that enable automated processing.

*Characteristics of executable specifications:*
- Formal syntax (RDF/Turtle)
- Validation rules (SHACL shapes)
- Extraction patterns (SPARQL queries)
- Generation templates (Tera templates)
- Testable criteria (Given-When-Then)

[See also: Semantic Foundation, Shape Constraint, Constitutional Equation]

---

**Extraction**
: See Extraction Query.

---

**Extraction Query**
: A SPARQL query (μ₂) that pulls structured data from validated RDF for template rendering. Extraction queries transform the graph into tabular data suitable for template consumption.

*Example:*
```sparql
SELECT ?name ?description ?args WHERE {
    ?cmd a sk:Command ;
         rdfs:label ?name ;
         sk:description ?description .
    OPTIONAL { ?cmd sk:hasArgument ?args }
}
```

[See also: SPARQL, Template Emission, Property Path]

---

## F

**Feedback Loop**
: The connection between production reality and specification evolution. Feedback loops collect data from running capabilities (telemetry, user feedback, outcome measurements), analyze it for insights, and channel improvements back to specification refinement.

*Feedback loop components:*
- **Collection**: Gather data from production
- **Analysis**: Extract actionable insights
- **Prioritization**: Rank by importance and gap
- **Refinement**: Update specifications
- **Regeneration**: Transform to artifacts

[See also: Outcome Measurement, Gap Analysis, Specification Refinement]

---

**Forces**
: The tensions that make problems genuinely difficult—often pulling in different directions simultaneously. Forces create trade-offs that specifications must resolve. Understanding forces reveals why simple solutions don't work.

*Common force pairs:*
- Speed vs. thoroughness
- Flexibility vs. consistency
- Simplicity vs. power
- Security vs. usability
- Innovation vs. stability

[See also: Forces in Tension, Customer Job, Competing Solutions]

---

## G

**Gap**
: The difference between current performance and target performance on an outcome. Gaps are calculated as `Gap = |Target - Current|` and used with importance to prioritize improvements: `Priority = Importance² × Gap`.

*Gap categories:*
- **Over-served**: Current > Target (can simplify)
- **Under-served**: Current < Target (must improve)
- **Met**: Current ≈ Target (maintain)

[See also: Gap Analysis, Outcome Measurement, Outcome Desired]

---

**Gap Analysis**
: The process of comparing current performance against targets to identify improvement opportunities. Gap analysis produces prioritized lists of improvements based on importance and gap size.

*Gap analysis formula:*
```
Priority = Importance² × Gap

Where:
- Importance: How much this outcome matters (1-10)
- Gap: |Target - Current|
- Priority: Relative urgency of improvement
```

[See also: Outcome Measurement, Specification Refinement, Feedback Loop]

---

**ggen**
: The transformation tool that implements the μ pipeline, converting RDF specifications to artifacts. ggen reads specifications, validates with SHACL, extracts with SPARQL, renders with Tera, canonicalizes output, and generates receipts.

*ggen commands:*
- `ggen sync`: Transform specs to artifacts
- `ggen verify`: Verify receipts match artifacts

[See also: Constitutional Equation, Transformation Pipeline, Receipt]

---

**Graph**
: See RDF Graph.

---

## H

**Habit**
: An established pattern of behavior that creates inertia against change. Habits are the "push of the present"—forces that keep people using existing solutions even when better alternatives exist.

*Habit categories:*
- **Procedural**: How we do things
- **Cognitive**: How we think about things
- **Social**: How we interact with others
- **Organizational**: How teams operate

[See also: Anxiety, Competing Solutions, Forces in Tension]

---

**Human-Readable Artifact**
: Generated output designed for human consumption. Human-readable artifacts have clear structure, helpful comments, consistent formatting, and meaningful organization—even though they're machine-generated.

*Human-readable characteristics:*
- Logical organization
- Helpful comments
- Consistent formatting
- Meaningful names
- Clear boundaries between sections

[See also: Artifact, Template Emission, Living Documentation]

---

## I

**Idempotent Transform**
: A transformation where running it twice produces the same result as running it once: μ ∘ μ = μ. Idempotence is essential for reliable regeneration—you can always regenerate safely.

*Idempotence requirements:*
- Deterministic extraction
- Stable template rendering
- Consistent canonicalization
- No time-dependent content (or controlled timestamps)
- No random content (or seeded randomness)

[See also: Canonicalization, Constitutional Equation, Drift Detection]

---

**Importance**
: A measure of how much an outcome matters to customers, typically on a 1-10 scale. Importance is distinct from satisfaction—a highly important outcome can be poorly satisfied, creating opportunity.

*Importance levels:*
- 9-10: Critical, make-or-break
- 7-8: Important, significant impact
- 5-6: Moderate, nice to have
- 3-4: Minor, rarely noticed
- 1-2: Negligible, not considered

[See also: Outcome Desired, Gap Analysis, Satisfaction]

---

**Inference Rule**
: A rule that derives new facts from existing ones, keeping specifications DRY. Inference happens at query time, expanding what SPARQL queries can find without duplicating information in source specifications.

*Example:*
```turtle
# Rule: Commands with only optional arguments are "simple"
?cmd rdf:type sk:SimpleCommand :-
    ?cmd rdf:type sk:Command ;
         sk:hasArgument ?arg .
    NOT EXISTS {
        ?arg sk:required true .
    }
```

[See also: Property Path, SPARQL, Semantic Foundation]

---

**Integration Reality**
: Testing with real dependencies rather than mocks. Integration reality tests verify that capabilities work in production-like conditions with actual databases, APIs, and services.

*Integration levels:*
- **Unit**: Isolated, mocked dependencies
- **Integration**: Real dependencies, controlled environment
- **End-to-end**: Full system, production-like
- **Production**: Actual production (canary, shadow)

[See also: Contract Test, Continuous Validation, Observable Execution]

---

## J

**JTBD (Jobs To Be Done)**
: A framework focused on understanding the progress customers are trying to make, not just features they request. JTBD reveals why people "hire" products and what outcomes they seek.

*JTBD core concepts:*
- **Job**: Progress sought in a circumstance
- **Hiring**: Choosing a solution for a job
- **Firing**: Abandoning a solution that fails
- **Outcome**: Measurable success criteria
- **Forces**: What pushes/pulls toward change

[See also: Customer Job, Outcome Desired, Circumstance of Struggle]

---

## L

**Layered Ontology**
: Organization of concepts by abstraction level—universal, framework, domain, and instance layers. Each layer builds on lower layers without creating circular dependencies.

*Ontology layers:*
```
┌─────────────────────────────────────────┐
│ L4: Instance Layer                       │
│     Specific implementations             │
├─────────────────────────────────────────┤
│ L3: Domain Layer                         │
│     Domain-specific concepts             │
├─────────────────────────────────────────┤
│ L2: Framework Layer                      │
│     Reusable patterns                    │
├─────────────────────────────────────────┤
│ L1: Universal Layer                      │
│     RDF, RDFS, OWL, SHACL               │
└─────────────────────────────────────────┘
```

[See also: Vocabulary Boundary, Semantic Foundation, Ontology]

---

**Living Documentation**
: Documentation generated from specifications that updates automatically when specifications change. Living documentation never drifts because it's always regenerated—a direct application of the constitutional equation.

*Living documentation benefits:*
- Always current
- Consistent with code
- Verifiable accuracy
- Single source of truth

[See also: Constitutional Equation, Human-Readable Artifact, Multi-Target Emission]

---

**Living System**
: The interconnected web of people, tools, processes, and culture that a capability joins. Understanding the living system reveals integration points, constraints, and opportunities that affect capability design.

*Living system components:*
- **People**: Users, operators, stakeholders
- **Tools**: Existing software, hardware
- **Processes**: Workflows, procedures
- **Culture**: Values, habits, norms
- **Connections**: How components interact

[See also: Forces in Tension, Competing Solutions, Customer Job]

---

## M

**μ (mu)**
: The transformation function in the constitutional equation. μ consists of five stages: normalize (μ₁), extract (μ₂), emit (μ₃), canonicalize (μ₄), and generate receipt (μ₅).

*μ pipeline:*
```
feature.ttl → μ₁ → μ₂ → μ₃ → μ₄ → μ₅ → spec.md + receipt.json
              │     │     │     │     │
              │     │     │     │     └─ μ₅: Receipt
              │     │     │     └─ μ₄: Canonicalize
              │     │     └─ μ₃: Emit
              │     └─ μ₂: Extract
              └─ μ₁: Normalize
```

[See also: Constitutional Equation, Normalization Stage, Extraction Query, Template Emission, Canonicalization, Receipt Generation]

---

**Multi-Target Emission**
: Generating multiple output formats from a single specification. Multi-target emission enables one source to produce code, documentation, tests, and configuration without duplication.

*Example targets:*
- Python module (.py)
- TypeScript interface (.ts)
- API documentation (.md)
- OpenAPI schema (.yaml)
- Test fixtures (.json)

[See also: Template Emission, Single Source of Truth, Living Documentation]

---

## N

**Namespace**
: See Vocabulary Boundary.

---

**Narrative Specification**
: Human context (rationale, scenarios, alternatives) embedded in formal specifications. Narrative specification preserves the "why" alongside the "what," making specifications understandable to humans while remaining machine-processable.

*Narrative elements:*
- **Rationale**: Why this design choice?
- **Scenarios**: Example usage situations
- **Alternatives**: What was considered?
- **History**: How did this evolve?

[See also: Executable Specification, Human-Readable Artifact, Living Documentation]

---

**Normalization Stage**
: The first stage (μ₁) of transformation that validates source against SHACL shapes. Normalization ensures specifications conform to expected structure before transformation proceeds.

*Normalization checks:*
- Syntax validity (valid Turtle)
- Shape conformance (SHACL validation)
- Required properties present
- Property types correct
- Cardinality constraints met

[See also: Shape Constraint, SHACL, Constitutional Equation]

---

## O

**Observable Execution**
: Instrumentation of capabilities with telemetry—traces, metrics, and logs—for understanding and debugging. Observable execution provides the data that feeds outcome measurement and gap analysis.

*Telemetry types:*
- **Traces**: Request flow through system
- **Metrics**: Aggregate measurements
- **Logs**: Event records
- **Events**: Business-level happenings

[See also: Outcome Measurement, Feedback Loop, Continuous Validation]

---

**Ontology**
: A formal specification of concepts, relationships, and constraints in a domain. Ontologies define the vocabulary and rules that specifications use.

*Ontology components:*
- **Classes**: Types of things
- **Properties**: Relationships and attributes
- **Constraints**: Rules about valid combinations
- **Instances**: Specific examples

[See also: Layered Ontology, Vocabulary Boundary, Semantic Foundation]

---

**Outcome**
: The measurable result customers seek from making progress on a job. Outcomes have direction (minimize/maximize), metric, and object. Well-defined outcomes enable measurement and gap analysis.

*Outcome structure:*
```
[Direction] + [Metric] + [Object]

Examples:
- Minimize the time to find relevant documentation
- Maximize the likelihood of catching bugs before production
- Minimize the effort to maintain generated code
```

[See also: Outcome Desired, Outcome Measurement, Gap Analysis]

---

**Outcome Desired**
: A pattern for defining measurable success criteria based on customer jobs. Outcome Desired captures what customers actually want to achieve, not proxy metrics.

[See also: Customer Job, Acceptance Criterion, Gap Analysis]

---

**Outcome Measurement**
: Tracking whether customers achieve their desired outcomes—not just whether features work. Outcome measurement connects telemetry to customer-centric success metrics.

[See also: Outcome Desired, Observable Execution, Gap Analysis]

---

**OWL (Web Ontology Language)**
: A semantic web standard for defining class hierarchies, property characteristics, and logical constraints. OWL extends RDFS with more expressive constructs.

*OWL features:*
- Class equivalence and disjointness
- Property characteristics (transitive, symmetric, inverse)
- Cardinality restrictions
- Property domain and range

[See also: RDF, RDFS, Ontology]

---

## P

**Partial Regeneration**
: Transforming only the artifacts affected by a change, rather than everything. Partial regeneration trades completeness for speed in large codebases with many specifications.

*Partial regeneration requirements:*
- Dependency tracking
- Change detection
- Isolated transformations
- Full regeneration for verification

[See also: Idempotent Transform, Constitutional Equation, Continuous Validation]

---

**Pattern**
: A recurring solution to a problem in a context, with explicit forces and trade-offs. Patterns capture proven solutions in a form that can be applied to similar situations.

*Pattern components (Alexander style):*
- **Context**: When this pattern applies
- **Problem**: What difficulty arises
- **Forces**: Tensions that make it hard
- **Therefore**: The solution approach
- **Resulting Context**: What you now have

[See also: Pattern Language, Forces]

---

**Pattern Language**
: A network of interconnected patterns that form a generative grammar for creating things. Pattern languages differ from pattern catalogs—they have structure, sequence, and inter-pattern relationships.

*Pattern language properties:*
- Patterns reference other patterns
- Patterns build on each other
- The whole is greater than parts
- Generates coherent wholes

[See also: Pattern, Pattern Connections]

---

**Pipeline**
: See Transformation Pipeline.

---

**Predicate**
: The relationship component of an RDF triple, connecting subject to object. Predicates are typically URIs from defined vocabularies.

*Example:*
```turtle
sk:validate   sk:description   "Validate specifications" .
#   ↑              ↑                    ↑
# subject      predicate            object
```

[See also: Triple, RDF, Subject, Object]

---

**Progress Maker**
: Anything that helps customers make progress on their jobs—tools, processes, workarounds. Understanding current progress makers reveals customer expectations and competitive baseline.

[See also: Customer Job, Competing Solutions, Anxieties and Habits]

---

**Property Path**
: SPARQL syntax for navigating multi-hop relationships in RDF graphs. Property paths enable queries across graph structures without verbose joins.

*Property path operators:*
- `/` : Sequence (a/b means a then b)
- `|` : Alternative (a|b means a or b)
- `*` : Zero or more
- `+` : One or more
- `?` : Zero or one

*Example:*
```sparql
# Find all transitive dependencies
?cmd sk:depends+/sk:dependency ?dep .
```

[See also: SPARQL, Extraction Query, Traceability Thread]

---

## R

**RDF (Resource Description Framework)**
: A semantic web standard for representing knowledge as subject-predicate-object triples. RDF provides the universal substrate for specifications in this pattern language.

*RDF key concepts:*
- **Triple**: Subject-predicate-object statement
- **URI**: Universal identifier
- **Literal**: String, number, date values
- **Graph**: Collection of triples

[See also: Triple, Turtle, SPARQL, Semantic Foundation]

---

**RDF Graph**
: A collection of RDF triples forming a directed graph. Subjects and objects are nodes; predicates are edges. RDF graphs can be merged, queried, and validated.

[See also: RDF, Triple, SPARQL]

---

**RDFS (RDF Schema)**
: A vocabulary for defining class and property hierarchies in RDF. RDFS provides `rdfs:Class`, `rdfs:subClassOf`, `rdfs:domain`, `rdfs:range`, and other foundational terms.

[See also: RDF, OWL, Ontology]

---

**Receipt**
: Cryptographic proof that an artifact was correctly generated from its source specification. Receipts record hashes at each pipeline stage, enabling verification that nothing was tampered with.

*Receipt contents:*
- Source specification hash
- Each pipeline stage hash
- Final artifact hash
- Timestamp
- Tool version

[See also: Receipt Generation, Receipt Verification, Drift Detection]

---

**Receipt Generation**
: The fifth stage (μ₅) of the transformation pipeline that creates cryptographic receipts. Receipt generation captures hashes at each stage for later verification.

[See also: Receipt, Receipt Verification, Constitutional Equation]

---

**Receipt Verification**
: Checking that receipts match current artifacts. Receipt verification can detect drift, tampering, and incomplete regeneration.

[See also: Receipt, Receipt Generation, Drift Detection]

---

**Refinement**
: See Specification Refinement.

---

## S

**Satisfaction**
: A measure of how well current solutions meet customer expectations on an outcome, typically on a 1-10 scale. Satisfaction combined with importance reveals opportunity.

*Opportunity = Importance + (Importance - Satisfaction)*

Where high importance and low satisfaction = high opportunity.

[See also: Importance, Gap Analysis, Outcome Measurement]

---

**Semantic Foundation**
: The formal language (RDF) chosen for representing specifications. The semantic foundation provides the substrate on which all other specification patterns build.

[See also: RDF, Executable Specification, Single Source of Truth]

---

**SHACL (Shapes Constraint Language)**
: A W3C standard for validating RDF data against shape definitions. SHACL defines what valid specifications look like and catches violations before transformation.

*SHACL constraint types:*
- **Property constraints**: Required, datatype, cardinality
- **Shape constraints**: Class membership, node patterns
- **Value constraints**: In-list, pattern matching
- **Logical constraints**: And, or, not, xone

[See also: Shape Constraint, Shape Validation, Normalization Stage]

---

**Shape**
: See Shape Constraint.

---

**Shape Constraint**
: A formal definition of valid specification structure using SHACL. Shape constraints catch invalid specifications before they corrupt downstream artifacts.

*Example shape:*
```turtle
sk:CommandShape
    a sh:NodeShape ;
    sh:targetClass sk:Command ;
    sh:property [
        sh:path rdfs:label ;
        sh:minCount 1 ;
        sh:datatype xsd:string
    ] .
```

[See also: SHACL, Shape Validation, Normalization Stage]

---

**Shape Validation**
: Running SHACL validation to check specifications against shapes. Shape validation is typically part of continuous validation, running on every commit.

[See also: SHACL, Shape Constraint, Continuous Validation]

---

**Single Source of Truth**
: One authoritative location for each piece of knowledge, eliminating duplication and drift. The single source enables the constitutional equation—artifacts derive from source, never the reverse.

*Single source principles:*
- One location per fact
- All artifacts derive from source
- Edits happen at source only
- Derivation is automated

[See also: Constitutional Equation, Drift, Semantic Foundation]

---

**SPARQL**
: Query language for RDF data. SPARQL enables extraction of structured data from RDF graphs for template rendering.

*SPARQL query types:*
- **SELECT**: Return tabular results
- **CONSTRUCT**: Return RDF graph
- **ASK**: Return boolean
- **DESCRIBE**: Return description

[See also: Extraction Query, Property Path, RDF]

---

**Specification**
: A formal description of a capability or its components. In this pattern language, specifications are written in RDF/Turtle and include structural definitions, constraints, and narratives.

[See also: Executable Specification, Semantic Foundation, Constitutional Equation]

---

**Specification Refinement**
: The disciplined practice of improving specifications based on feedback while maintaining consistency. Refinement follows a workflow: propose, review, validate, commit, regenerate.

*Refinement types:*
- **Additive**: New capabilities
- **Corrective**: Bug fixes
- **Clarifying**: Better expression
- **Optimizing**: Performance
- **Deprecating**: Retirement

[See also: Feedback Loop, Gap Analysis, Constitutional Equation]

---

**Subject**
: The entity that an RDF triple makes a statement about. Subjects are typically URIs or blank nodes.

[See also: Triple, Predicate, Object]

---

## T

**Telemetry**
: See Observable Execution.

---

**Template**
: See Template Emission.

---

**Template Emission**
: The third stage (μ₃) of transformation that renders Tera templates with extracted data. Template emission produces the actual artifact content.

*Tera template features:*
- Variable interpolation: `{{ name }}`
- Control flow: `{% if %}`, `{% for %}`
- Filters: `{{ name | upper }}`
- Includes: `{% include "partial.tera" %}`

[See also: Tera, Extraction Query, Canonicalization]

---

**Tera**
: A template engine with Jinja2-like syntax used for artifact generation. Tera templates consume extracted data and produce output files.

[See also: Template Emission, ggen]

---

**Test Before Code**
: Writing tests (generated from specifications) before implementing capabilities. Test Before Code ensures tests exist and guides implementation toward specified behavior.

[See also: Contract Test, Acceptance Criterion, Continuous Validation]

---

**Traceability**
: See Traceability Thread.

---

**Traceability Thread**
: Explicit links connecting related artifacts across all levels—from customer jobs to outcomes to criteria to tests to code. Traceability enables impact analysis and requirement verification.

*Traceability chain:*
```
Job → Outcome → Criterion → Test → Code → Documentation
```

[See also: Acceptance Criterion, Constitutional Equation, Vocabulary Boundary]

---

**Transformation Pipeline**
: The five-stage process (μ) that converts specifications to artifacts. The pipeline ensures consistent, verifiable transformation.

*Pipeline stages:*
1. μ₁: Normalize (SHACL validation)
2. μ₂: Extract (SPARQL query)
3. μ₃: Emit (Tera template)
4. μ₄: Canonicalize (format)
5. μ₅: Receipt (hash proof)

[See also: Constitutional Equation, each stage pattern]

---

**Triple**
: The basic unit of RDF: subject, predicate, object. Triples make statements about resources in the world.

*Triple example:*
```turtle
sk:validate sk:description "Validate specifications" .
```

This triple states: "The validate command has description 'Validate specifications'."

[See also: RDF, Subject, Predicate, Object]

---

**Turtle (Terse RDF Triple Language)**
: A human-readable serialization format for RDF. Turtle is the preferred format for hand-written specifications due to its readability.

*Turtle features:*
- Prefix declarations: `@prefix sk: <...> .`
- Subject grouping: `sk:cmd a sk:Command ; rdfs:label "cmd" .`
- Blank nodes: `[ a sk:Argument ; sk:name "file" ]`
- Comments: `# This is a comment`

[See also: RDF, Triple, Semantic Foundation]

---

## U

**URI (Uniform Resource Identifier)**
: A unique identifier for resources in RDF. URIs enable global, unambiguous naming of concepts.

*URI examples:*
- `http://example.org/spec-kit#validate`
- `https://schema.org/name`
- `urn:uuid:12345678-1234-1234-1234-123456789012`

[See also: RDF, Triple, Vocabulary Boundary]

---

## V

**Validation**
: See Shape Validation or Continuous Validation.

---

**Verification Pattern**
: A pattern focused on ensuring correctness—testing, validation, drift detection. Verification patterns comprise Part IV of this pattern language.

[See also: Shape Validation, Drift Detection, Receipt Verification]

---

**Vocabulary Boundary**
: Namespace separation that keeps domain concepts distinct. Vocabulary boundaries prevent collision between terms from different domains and enable controlled evolution.

*Namespace prefixes:*
```turtle
@prefix sk: <http://example.org/spec-kit#> .
@prefix jtbd: <http://example.org/jtbd#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
```

[See also: Layered Ontology, Semantic Foundation, Ontology]

---

## W-Z

**Warrant**
: Evidence or reasoning that justifies a claim or decision. In narrative specifications, warrants explain why design choices were made.

[See also: Narrative Specification]

---

## Symbols

**★** (One star)
: Confidence level indicating a promising pattern with less empirical validation. One-star patterns represent best current thinking but may require adaptation.

---

**★★** (Two stars)
: Confidence level indicating a well-established pattern with substantial evidence of success across multiple contexts. Two-star patterns can be applied with confidence.

---

**→** (Arrow)
: "Sets context for" or "enables." Pattern A → Pattern B means applying A creates conditions for B.

---

**↔** (Double arrow)
: "Completed by" or "works together with." Patterns A ↔ B are complementary and often used together.

---

**⟷** (Long double arrow)
: "Alternative to." Patterns A ⟷ B address similar problems with different approaches.

---

**⊢** (Turnstile)
: "Verified by." Pattern A ⊢ Pattern B means B verifies or checks A.

---

**μ** (Mu)
: The transformation function in the constitutional equation. See μ (mu) entry.

---

## Summary

This glossary defines 100+ terms essential to understanding and applying specification-driven development. The vocabulary forms a coherent system—terms reference each other and build toward the constitutional equation.

Key term clusters:
- **Foundation**: RDF, Triple, URI, Turtle, SPARQL, SHACL
- **Structure**: Ontology, Vocabulary, Layer, Shape
- **Process**: Constitutional Equation, μ, Pipeline, Stage
- **Quality**: Validation, Verification, Drift, Receipt
- **Evolution**: Feedback, Outcome, Gap, Refinement

Master these terms and you master the language of specification-driven development.

---

**Next:** See **[References](./references.md)** for sources and further reading.
